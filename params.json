{"name":"Esopsis.GitHub.io","tagline":"Eric James Parfitt's Programming Projects","body":"(This page is most definitely under construction)\r\n\r\n##My Projects\r\nThese projects are generally ordered by when I made them, from newest to oldest.  Since I've mainly been teaching myself to code, the code in some of the newer projects might be a little better put together than in the older ones.  I seem to tend to work on projects which are visual in some way, and that perhaps have some kind of chaotic behavior.\r\n\r\n##Cellular Automaton Tiles\r\nA Dr. Paul Harrison has found a way to make universal cellular automaton tiles, [here](http://www.logarithmic.net/pfh/blog/01104447019).  His tiles can emulate any of the 256 elementary cellular automaton.  I, however, found a smaller set of tiles with a smaller number of types of sides that emulates just rule 110. And it's prettier ;-)  Here are some images of some tiles I printed out on magnetic paper and put on my refrigerator:\r\n\r\n![Simple initial condition](https://raw.githubusercontent.com/esopsis/Images/master/SimpleTiles.jpg)\r\n![Less simple initial condition](https://raw.githubusercontent.com/esopsis/Images/master/LessSimpleTiles.jpg)\r\n\r\nHere is a link to the source code for a project I am working on which will allow one to play around with the tiles on a computer.  Eventually I am thinking of making it into a mobile app.\r\n\r\nhttps://github.com/esopsis/Rule110Tiles\r\n\r\nAnd [here](https://github.com/esopsis/Images/blob/master/Rule%20110%20Tiles.svg) is the vector graphics file with which one can print their own tiles out on magnetic paper with a regular inkjet printer (office supply stores often carry it.)  I reccomend opening the file with a vector graphics program like [Inkskape](https://inkscape.org/en/).  You can also arrange the tiles using that program, but it's not QUITE the samee as my own Python program I don't think ;-)\r\n\r\n##Invented Font\r\nThis program is designed for coding and decoding the roman alphabet into and out of a character set I made up.  My characters are all made up of either one or two of a set of four different character parts which can be combined in different ways to get a total of 30 new characters.  Here's the translator in action:\r\n\r\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/R6eeP4APLUo\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nAnd here's a familiar English phrase I wrote with the characters by hand:\r\n\r\n![Ericbic sample](https://raw.githubusercontent.com/esopsis/Images/master/Ericbic.jpg)\r\n\r\nHere's the code for the translator:\r\n\r\nhttps://github.com/esopsis/Ericbic\r\n\r\n##Base Infinity\r\nBase 2 has 2 sybols, base 10 has 10 symbols, so, logically, base infinity has an infinite number of symbols, one for each non-negative integer.  Here is a video showing an interpretation of base infinity that I made:\r\n\r\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Xgjaz-o8oGc\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nAnd here is some code I used for making these symbols:\r\n\r\nhttps://github.com/esopsis/BaseInfinity\r\n\r\n##Cannibalistic Explodey Guys\r\nHere's a video of a simple \"mindless fun\" kind of \"game\" I made.  You click on a guy and he explodes, then his little friends come and eat him.  Exciting.\r\n\r\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/A25d2ece-SQ\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nAnd here's the code:\r\n\r\nhttps://github.com/esopsis/ExplodeyGuys\r\n\r\n##Physical Cyclic Tag System\r\nHere is a program for creating “Rube Goldberg” style contraptions consisting of balls, levers, ramps, and ropes.   One advantage this program might have over others is that the balls move in discrete jumps, so one can more easily get the behavior one desires, possibly without having to go through as much trial and error.  I made this program primarily to show how it would be possible to make a “physical” system which emulates  a kind of simple program called a cyclic tag system.  This idea was first presented by Stephen Wolfram in his book [A New Kind of Science](http://www.wolframscience.com/nksonline/toc.html), but without an actual implementation.   Below is an implementation of system d on NKS page 96.  See pages 96 and 895 at the NKS book link for more information.\r\n\r\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/PlPmJRq1NFw\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nHere is the code:\r\n\r\nhttps://github.com/esopsis/CyclicTag\r\n\r\n##Binary Evaluator\r\nHere are a couple of programs which simply turn a binary sequence into a series of left and right turns.  In the first case, if two paths would overlap, the program shifts over and begins drawing again.  In the second case, the program attempts to avoid hitting itself, in such a way that different binary sequences always produce a different pattern (not necessarily the case in the first program.)  Both are working with the first 123 digits of pi.\r\n\r\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/7hdQodrf3Fw\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nHere's the code:\r\n\r\nhttps://github.com/esopsis/BinaryEvaluator\r\n\r\n##Self Avoiding Hexagonal Branching\r\nHere's a program I wrote which starts with a single branch and continues drawing branches at the ends of each previous branch. Going clockwise, branches are added except when a branch would collide with the end of an existing branch .  I came up with this one while doodling in class.  It made an interesting pattern on paper, so I implemented it on the computer.  This is one of the first programs I wrote in Mathematica, but I also wrote a Python version before that. \r\n\r\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/n5vxTY-YcJ4\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nHere's the code in Python:\r\n\r\nhttps://github.com/esopsis/Branchles\r\n\r\nAnd here's a demonstration I posted, using Mathematica (the code can be found on this page):\r\n\r\nhttp://demonstrations.wolfram.com/SelfAvoidingHexagonalBranching/\r\n\r\nHere's a program which interprets the evolution of a [rule 110 cellular automaton](https://en.wikipedia.org/wiki/Rule_110) as a bunch of different colord triangle-oid shapes.  A randomizing element runs slowly from right to left on the screen, to keep the evolution from dying down. \r\n\r\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/9UrcrwEgySE\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nHere's the code:\r\n\r\nhttps://github.com/esopsis/CAColorRandomizer\r\n\r\n##Reversible CA\r\nHere's a program which runs a reversible cellular automaton, Wolfram's Rule 37R.  The program colors three different kinds of patterns in the overall pattern in different colors, to help visualize them better.  A second version draws borders between these patterns.\r\nThe code is a modified version of a [program](http://sjsu.rudyrucker.com/~kwanghyung.paek/applet/) by Kwanghyun Pek.\r\n\r\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BK4H-F08Au4\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nHere's the code:\r\n\r\nhttps://github.com/esopsis/ReversibleCA\r\n\r\n##The Beginnings of a 4D Battle Tank Game\r\nHere are two programs, one which takes 2D slices of a 3D terrain, and one which takes 4D slices of a 3D terrain.  I intend to make these into some kind of battle tank game eventually.\r\n\r\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/DCx_ySujStE\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nHere's the code for both:\r\nhttps://github.com/esopsis/3DSlicer\r\nhttps://github.com/esopsis/4DSlicer\r\n\r\nThe 4D version uses code from a [tutorial]http://nehe.gamedev.net/tutorial/beautiful_landscapes_by_means_of_height_mapping/16006/ from nehe.gamedev.net, namely lesson 34 which shows how to make a 3D terrain from a shaded 2D bitmap.\r\n\r\n##Word Frequency Sorter\r\nFinally, here's a simple project which just takes both a list of words, and a list of expected word frequences, and puts the words in order of how much more they are found in the first list as compared with the second list of expected values.\r\n\r\nhttps://github.com/esopsis/RelativeWordFrequencies\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}